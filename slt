#!/usr/bin/perl
use strict;
use warnings;
use POSIX qw(strftime);
use Time::Piece;
use Term::ReadKey;
use Getopt::Long;
use Term::ANSIColor;

# Configuration
my ( $bucket_size_minutes, $bucket_size_seconds ) = 0;
my %log_counts;			# this is where the counts of log entries are tallied across the time buckets
my $legend_length = 0;
my $range_start = "";
my $range_end = "";
my $range_start_epoch = 0;
my $range_end_epoch = 0;
my %range_epoch = ( 'start' => 0, 'end' => 2521843200 );
my %range;
my( $exclude_regex, $include_regex, $highlight_regex );
my $pause_output = 0;
my $hide_values = 0;
my @in_files;
my ($terminal_width, $terminal_height) = GetTerminalSize();
my @log_levels = qw(ERROR-HL ERROR WARN-HL WARN INFO-HL INFO DEBUG-HL DEBUG TRACE-HL TRACE);						# Define log bucket printing order

# TO DO:
# - add a summary table at the end showing totals in the various buckets

# - add a feature to allow providing start and end times where entries outside of that range are omitted
# - add a feature to auto-detect if the file is an access log or normal log (ie; 500 or ERRROR)
# - add capabilities to do access log mode inspecting number of requests and status codes
# - add feature to auto-calculate time window bucket based on terminal height and min and max time range in file (this would be based on previous file reads)
# - add a feature allowing for auto-detection of file type, and hence analysis pattern/options to use
# - add a feature to allow gfor grouping of various other log categories like ThreadPool or Object context (instead of errors)
# - add a mode to go down to second precision

# RAC client: [2025-02-04T12:06:22.784] [TRACE] MessageStream - handling data from GAS with chunk size: 88
my %colors = (
    'ERROR' => "\033[0;31m",
    'WARN'  => "\033[0;33m",
    'INFO'  => "\033[0;32m",
    'DEBUG' => "\033[0;34m",
    'TRACE' => "\033[0;35m",
    'NC'    => "\033[0m"
);

# ANSI code for yellow background
my $white_fg  = "\033[1;37m"; # Bright White Foreground
#my $yellow_bg = "\033[43m";  # Yellow background
my $yellow_bg = "\033[48;5;229m";  # Very pale yellow background
#my $yellow_bg = "\033[48;5;222m";  # Light gold background
#my $yellow_bg = "\033[48;5;216m";  # Pastel yellow background
my $reset_all    = "\033[0m";  # Reset ALL attributes

# Create new keys with -HL and yellow background
foreach my $key (keys %colors) {
    next if $key eq 'NC';  # Skip NC
    my $new_key = "$key-HL";
    #$colors{$new_key} = "$colors{$key}$yellow_bg";			# Apply a yellow background on top of the existing FG color
    
   my $original_fg_color = $colors{$key}; # Get original foreground

    # Extract the original colour code from the FG code
    $original_fg_color =~ s/^\e\[(.*?)m/$1/g;

    my $bg_color_256;
    if ($original_fg_color eq "0;31") {    # Red
        $bg_color_256 = "196";            # 256-color code for Red
    } elsif ($original_fg_color eq "0;33") { # Yellow
        $bg_color_256 = "226";            # 256-color code for Yellow
    } elsif ($original_fg_color eq "0;32") { # Green
        $bg_color_256 = "46";             # 256-color code for Green
    } elsif ($original_fg_color eq "0;34") { # Blue
        $bg_color_256 = "21";             # 256-color code for Blue
    } elsif ($original_fg_color eq "0;35") { # Magenta
        $bg_color_256 = "201";            # 256-color code for Magenta
    } else {
        $bg_color_256 = "0";              # Black background as default
    }

    #$colors{$new_key} = "\033[48;5;${bg_color_256}m${white_fg}";
    $colors{$new_key} = "$colors{$key}\033[48;5;${bg_color_256}m";
  #  print "$original_fg_color\n";
}

#foreach my $key (keys %colors){
#    print "Testing: $key\n";
#    print "$colors{$key}This is $key with \$colors{'NC'} $reset_all\n";
#}


## SUBS ##

sub print_title {
    my $title = <<"END";
\033[0;37m
──────────────────────────────────────────────────────────────────────────────────────────────

   ,:: slt ::' simple log timeline  --  by Greg Eva // geva\@ptc.com || gregeva\@gmail.com

──────────────────────────────────────────────────────────────────────────────────────────────
\033[0m
END
    print $title;
    return;
}

sub adapt_to_command_line_options {
    # Get command-line options
    GetOptions(
        'bucket-size|bs=i' => \$bucket_size_minutes,
        'pause|p' => \$pause_output,
        'hide-values|hv' => \$hide_values,
        'start|s=s' => \$range_start,
        'end|e=s' => \$range_end,
        'exclude|e=s' => \$exclude_regex,
        'include|i=s' => \$include_regex,
        'highlight|h=s' => \$highlight_regex
    ) or die "Usage: $0 --bucket-size | -bs <minutes> <file1> <file2> ...\n";

    $range{'start'} = $range_start if defined( $range_start );
    $range{'end'} = $range_end if defined(  $range_end );

    # Ensure at least one file is provided
    @in_files = @ARGV;
    die "Usage: $0 --bucket-size | -bs <minutes> <file1> <file2> ...\n" unless @in_files;

    $bucket_size_seconds = $bucket_size_minutes * 60;

    # Parse various possible formats for input of start and end times and set associated filter variables
    # BUG: specifying only the time should default to the date included in the file, however at this point we've not yet read the file
    foreach my $key (keys %range) {
        my $value = $range{$key};  # Get the value (either $range_start or $range_end)
        next unless length( $range{$key} ) > 0;
        my $epoch_value;  # Variable to store the epoch time

        # Convert timestamp to epoch seconds using Time::Piece
        if ( $value =~ /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/ ) {
            $epoch_value = Time::Piece->strptime( $value, "%Y-%m-%d %H:%M:%S" )->epoch;
        } elsif ( $value =~ /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}/ ) {
            $epoch_value = Time::Piece->strptime( $value, "%Y-%m-%d %H:%M" )->epoch;
        } elsif ( $value =~ /^\d{4}-\d{2}-\d{2}/ ) {
            $epoch_value = Time::Piece->strptime( $value, "%Y-%m-%d" )->epoch;
        } elsif ( $value =~ /^\d{2}:\d{2}:\d{2}/ ) {
            $epoch_value = Time::Piece->strptime( $value, "%H:%M:%S" )->epoch;
        } elsif ( $value =~ /^\d{2}:\d{2}/ ) {
            $epoch_value = Time::Piece->strptime( $value, "%H:%M" )->epoch;
        } else {
        	print "Warning: unhandled date/time format - option not taken into account\n";
            #$epoch_value = undef;  # Or some appropriate default/error value
        }

        $range_epoch{$key} = $epoch_value if defined( $epoch_value );  # Store the epoch value in the hash
    }
    return;
}

sub adapt_to_terminal_settings {
    $terminal_width //= 80; # Default to 80 if terminal width cannot be determined
    $terminal_height //= 24; # Default to 24 if terminal height cannot be determined

    # Auto-adjust the bucket size based on the terminal height (larger terminal can handle more rows)
    if( $terminal_height <= 24 ) {
        $bucket_size_minutes = 60;
    } elsif( $terminal_height <= 45 ) {
        $bucket_size_minutes = 30;
    } elsif( $terminal_height <= 65 ) {
        $bucket_size_minutes = 10;
    } elsif( $terminal_height <= 85 ) {
        $bucket_size_minutes = 5;
    } elsif( $terminal_height > 85 ) {
        $bucket_size_minutes = 1;
    } else {
        $bucket_size_minutes = 60;
    }
    #print "Terminal is: $terminal_width x $terminal_height -- Bucket size: $bucket_size_minutes\n";
    return;
}

sub pause_for_keypress {
    my ($prompt) = @_;  # Get the optional prompt message
    $prompt = "Press any key to continue (or Q to quit)..." unless defined $prompt;
    print "\033[0;44m$prompt\033[0m";

    ReadMode 4;  # Turn off line buffering
    my $key = ReadKey(0);
    ReadMode 0;  # Restore normal input mode

    if (defined $key) {
        if ($key eq "q" || $key eq "Q") {
            print "\r";
            print " " x length( $prompt );
            print "\r\033[0;35mExiting program.\033[0m\n";
            exit 0;
        } else {
            print "\r";
            print " " x length( $prompt );
            print "\r";
            return 1;  # Return a value indicating "continue"
        }
    } else {
        print "\r";
        print " " x length( $prompt );
        print "\r";
        return 1;
    }
}

# Parse logs, bucket by time, and count log levels
sub read_and_process_logs {
    # BUG: this should be able to take multiple files as inputs using * but it doesn't work, same for including multiple files
    foreach my $in_file (@in_files) {
        open my $fh, '<', $in_file or die "Cannot open file: $in_file";
        my $line_number = 0;
        while (<$fh>) {
            $line_number++;
            if ($line_number % 100 == 0) {
                printf("\rProcessing line %d in file %s", $line_number, $in_file);
                $| = 1; # Flush output
            }
            if (my ($timestamp_str, $log_level) = $_ =~ /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\.\d{3}\+\d{4} \[L: ([^\]]*)\]/) {
                my $log_level_bucket = $log_level;
                # Convert timestamp to epoch seconds using Time::Piece
                my $timestamp = Time::Piece->strptime($timestamp_str, "%Y-%m-%d %H:%M:%S")->epoch;

                # a number of conditions determine if this read row should be skipped
                next if( $timestamp < $range_epoch{'start'} || $timestamp >= $range_epoch{'end'} );
                next if( defined( $exclude_regex ) && /$exclude_regex/ );
                next if( defined( $include_regex ) && !/$include_regex/ );

                # determine if this line should be highlighted
                $log_level_bucket .= "-HL" if( defined( $highlight_regex ) && /$highlight_regex/ );

                my $bucket = int($timestamp / $bucket_size_seconds) * $bucket_size_seconds;
                $log_counts{$bucket}{$log_level_bucket}{count}++;
            }
        }
        close $fh;
    }
    print "\r\033[0;32mProcessing complete.\033[0m";
    print " " x ( $terminal_width - length( "Processing complete." ) );
    print "\n\n";

    return;
}

sub normalize_data_for_output {
    # Determine the maximum total log messages for any time window
    my $max_total_count = 0;
    foreach my $bucket (keys %log_counts) {
        my $total_count = 0;
        foreach my $log_level (keys %{$log_counts{$bucket}}) {
            $total_count += $log_counts{$bucket}{$log_level}{count};
        }
        $max_total_count = $total_count if $total_count > $max_total_count;
    }

    # Calculate the maximum length of log level titles and counts
    if( !$hide_values ) {
        foreach my $bucket (keys %log_counts) {
            my $bucket_legend_length = 0;
            foreach my $log_level (keys %{$log_counts{$bucket}}) {
                my $count = $log_counts{$bucket}{$log_level}{count};
		
                my $title_length = $log_level =~ /-HL$/ ? length(" $count ") : length("$log_level: $count ");
                $bucket_legend_length += $title_length;
            }
            $legend_length = $bucket_legend_length if $bucket_legend_length > $legend_length;
        }
    }

    # Normalize counts to fit terminal width
    my $max_graph_width = $terminal_width - $legend_length - 2 - 4 - 15;    # static values based on timestamp length, some white space, maybe a vertical line spacer
    foreach my $bucket (keys %log_counts) {
        foreach my $log_level (keys %{$log_counts{$bucket}}) {
            my $count = $log_counts{$bucket}{$log_level}{count};
            my $scaled_count = int(($count / $max_total_count) * $max_graph_width);
            $log_counts{$bucket}{$log_level}{scaled_count} = $scaled_count;
        }
    }
    return;
}

sub print_bar_graph {
    my $lines_printed = 0;
    foreach my $bucket (sort keys %log_counts) {
        my $bucket_time_str = strftime("%Y-%m-%d %H:%M", gmtime($bucket));
        #my $bucket_time_str = strftime("%Y-%m-%d %H:%M", localtime($bucket));			# don't use this as it is converting unknown timezone in logs to client timezome
        print "$bucket_time_str ";
        #print "$bucket  ";
        my $log_details = "";
        my $legend_length_bucket = 0;
        foreach my $log_level (@log_levels) {
            if (exists $log_counts{$bucket}{$log_level}) {
                my $count = $log_counts{$bucket}{$log_level}{count};
                my $color = $colors{$log_level} // $colors{'NC'};
                if( $log_level =~ /-HL$/ ) {
                    $log_details .= "${color}$count$colors{'NC'} ";
                    $legend_length_bucket += length("$count ");
                } else {
                    $log_details .= "$color$log_level: $count$colors{'NC'} ";
                    $legend_length_bucket += length("$log_level: $count ");
                }
            }
        }
        print $log_details unless $hide_values;
        my $padding = $legend_length - $legend_length_bucket;
        print " " x ($padding >= 0 ? $padding : 0);
        print "│ ";
        foreach my $log_level (@log_levels) {
            if (exists $log_counts{$bucket}{$log_level}) {
                my $scaled_count = $log_counts{$bucket}{$log_level}{scaled_count};
                my $color = $colors{$log_level} // $colors{'NC'};
                print "$color" . ('█' x $scaled_count) . "$colors{'NC'}";
            }
        }
        print "\n";
        pause_for_keypress() if( $pause_output && $lines_printed++ > 1 && $lines_printed % ( $terminal_height - 1 ) == 0 );
    }
    return;
}

## MAIN ##

print_title();
adapt_to_terminal_settings(); 
adapt_to_command_line_options();
read_and_process_logs();
normalize_data_for_output();
print_bar_graph();
exit;
