#!/usr/bin/perl
use strict;
use warnings;
use POSIX qw(strftime floor);
use Time::Piece;
use DateTime;
use Term::ReadKey;
use Getopt::Long;
use Term::ANSIColor;
use Time::HiRes qw(gettimeofday tv_interval);
use Proc::ProcessTable;
use List::Util qw(min);

# Start time
my $start_time = [gettimeofday];

# Configuration
my $version_number = "0.1.17";
my $log_base = 2;
my @rolling_window;
my $rolling_window_size = 10;								# Adjust this value as needed - more time buckets included in the rolling window will give better sample for Z-score
my ( $bucket_size_minutes, $bucket_size_seconds, $print_seconds, $print_milliseconds, $print_version, $omit_empty, $omit_summary, $omit_rate ) = 0;
my ( $current_memory_usage, $max_memory_usage, $end_time, $elapsed ) = ( 0, 0, 0, 0 );
my ( %log_counts, %category_totals, %log_analysis, %log_messages, %log_stats );		# this is where the counts of log entries are tallied across the time buckets
my $max_log_message_length = 0;							# used to define the maximum key length of the log message bucket counts
my $durations_graph_width = 0;
my $max_graph_width = 0;
my $print_durations = 0;
my ( $filter_duration_min, $filter_duration_max );
my ( $filter_bytes_min, $filter_bytes_max );
my $top_n_messages = 10;
my $total_lines_read = 0;
my $total_lines_included = 0;
my $total_lines_highlighted = 0;
my $legend_length = 0;
my $range_start = "";
my $range_end = "";
my $range_start_epoch = 0;
my $range_end_epoch = 0;
my %range_epoch = ( 'start' => 0, 'end' => 2521843200 );
my %range;
my $output_timestamp_format = "%Y-%m-%d %H:%M";
#my( $output_timestamp_min ) = DateTime->from_epoch( epoch => 1678886400 );
#my( $output_timestamp_min, $output_timestamp_max );
my $output_timestamp_min = 0;
my $output_timestamp_max = 0;
my( $exclude_regex, $include_regex, $highlight_regex );
my $pause_output = 0;
my $omit_values = 0;
my @in_files;
my ($terminal_width, $terminal_height) = GetTerminalSize();

# Define log bucket printing order
#my @log_levels = qw(ERROR-HL ERROR WARN-HL WARN INFO-HL INFO DEBUG-HL DEBUG TRACE-HL TRACE 5xx-HL 5xx 4xx-HL 4xx 3xx-HL 3xx 2xx-HL 2xx 1xx-HL 1xx empty );
my @log_levels = (
    'ERROR-HL', 'ERROR', 'WARN-HL', 'WARN', 'INFO-HL', 'INFO', 
    'DEBUG-HL', 'DEBUG', 'TRACE-HL', 'TRACE', '5xx-HL', '5xx', 
    '4xx-HL', '4xx', '3xx-HL', '3xx', '2xx-HL', '2xx', '1xx-HL', 
    '1xx', 'Pause Young-HL', 'Pause Young', 'Pause Full-HL', 'Pause Full',
    'err-rate', 'msg-rate', 'empty'
);

my %blocks = (
    'A' => '█',    # Full block
    'B' => '▓',    # Heavy shading
    'C' => '▒',    # Medium shading
    'D' => '░',    # Light shading
    'E' => '▪',    # Black Square
    'F' => '▫',    # White Square
    'G' => '☰',    # Menu
    'H' => '•',    # Bullet Point
    'I' => '■',    # Black Very Heavy
    'J' => '□'     # White square
);
my $default_chart_block = "A";

# TO DO:
# - cut off .0 from formatted output (number, bytes)
# - group similar messages together with unique part replacement mask #### based on memory used >50MB and messages where count is 1 (only group the lower ones) option to change the number considered which would essetially create different sets of message groups
# - separate code for printing the graph, generating the summary table, and the Top Messages
# - add pagination support for the summary overview and the top messages
# - create a conditional path to resize durations stats pane and only print available information if duration value is not present (also don't do the statistical calculations)
# - have the duration stats pane auto-size based on which data was found and is able to be displayed (bytes, duration, rates, etc.)
# - color and highlight CV and Z-score according to their values (want to make larger numbers jump out)
# - need to save X-axis charaters with all the information - when terminal width < X and all time windows on same day, omit printing the date on each line (instead print it at the start or end) - this saves 10 chars
# - add a summary table at the end showing totals in the various buckets (start, end time, total duration in time of logs, average logs per minute, second, size of the file, lines omitted/didn't match)
# - multi-threaded file reading
# - should add a time counter for reading the files, and one for the processing.  Today this is grouped together but with different I/O limitations and statistical calculations one or the other will fluctuate.

# - context detection and removal from log lines (maybe use bloom filter) - seek names in other lines, and then match on that in log lines and substitute the text (error in entity name Thing1)
# - add feature to auto-calculate time window bucket based on terminal height and min and max time range in file (this would be based on previous file reads, or better filesize)

## BUGS ##

# NOT PRIORITY BACKLOG
# - add a feature to include/exclude HTTP status codes which would need to be converted to RegEx as 4xx isn't going to be found
# - add a feature to allow for grouping of various other log categories like ThreadPool or Object context (instead of errors)
# - performance improvement: leverage a temp file with cached file stats (log start/end times, num lines, ...) to start/stop reading the file when provided start/end time ranges based on guesses around filesize
# - support for live tailing

## LOG STRUCTURES ##
# RAC client: [2025-02-04T12:06:22.784] [TRACE] MessageStream - handling data from GAS with chunk size: 88
# TWX logs: 2025-02-04 12:05:57.481+0000 [L: DEBUG] [O: c.t.p.p.StreamEntryProcessor] [I: ] [U: ] [S: ] [P: ] [T: pool-6-thread-3] Stream Entry Block Size Threshold Reached...
# Tomcat access logs: 10.224.212.63 - - [02/Feb/2025:00:00:11 +0000] "GET /Thingworx/Metrics?x-thingworx-session=false HTTP/1.1" 200 17626 295
# Catalina.out: 20-Feb-2025 08:55:05.055 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/app/opt/apache-tomcat/webapps/Thingworx] has finished in [37,549] ms
# GC Logs
# [2024-12-17T06:10:16.351+0000][29576.409s][info][gc             ] GC(25524) Pause Full (G1 Evacuation Pause) 17047M->16380M(17408M) 2459.735ms
# [2024-12-17T06:10:16.351+0000][29576.409s][info][gc,cpu         ] GC(25524) User=4.73s Sys=0.01s Real=2.46s
# [2024-12-17T06:10:16.993+0000][29577.052s][info][gc,start       ] GC(25525) Pause Young (Concurrent Start) (G1 Evacuation Pause)
# [2024-11-21T18:36:30.300+0000][info][gc            ] GC(16) Pause Young (Normal) (G1 Evacuation Pause) 949M->685M(9216M) 106.703ms
# 2021-05-11T07:41:12.706+0000: 0.578: [GC pause (G1 Evacuation Pause) (young), 0.0069706 secs]

my %colors = (
    'ERROR' => "\033[0;31m",
    'WARN'  => "\033[0;33m",
    'INFO'  => "\033[0;32m",
    'DEBUG' => "\033[0;34m",
    'TRACE' => "\033[0;35m",
    '1xx'  => "\033[0;34m",
    '2xx'  => "\033[0;32m",
    '3xx'  => "\033[0;35m",
    '4xx'  => "\033[0;33m",
    '5xx'  => "\033[0;31m",
    'Pause Young' => "\033[0;35m",
    'Pause Full' => "\033[0;31m",
    'err-rate' => "\033[91m\033[109m",
    'msg-rate'    => "\033[0m",
    'NC'    => "\033[0m",
    'black' => "\033[30m\033[49m",
    'red' => "\033[31m\033[49m",
    'green' => "\033[32m\033[49m",
    'yellow' => "\033[33m\033[49m",
    'blue' => "\033[34m\033[49m",
    'magenta' => "\033[35m\033[49m",
    'cyan' => "\033[36m\033[49m",
    'white' => "\033[36m\033[49m",
    'bright-black' => "\033[90m\033[109m",
    'bright-red' => "\033[91m\033[109m",
    'bright-green' => "\033[92m\033[109m",
    'bright-yellow' => "\033[93m\033[109m",
    'bright-blue' => "\033[94m\033[109m",
    'bright-magenta' => "\033[95m\033[109m",
    'bright-cyan' => "\033[96m\033[109m",
    'bright-white' => "\033[97m\033[109m",
    'black-underline' => "\033[4;30m",
    'red-underline' => "\033[4;31m",
    'green-underline' => "\033[4;32m",
    'yellow-underline' => "\033[4;33m",
    'blue-underline' => "\033[4;34m",
    'magenta-underline' => "\033[4;35m",
    'cyan-underline' => "\033[4;36m",
    'white-underline' => "\033[4;37m"
);

# ANSI code for yellow background
my $white_fg  = "\033[1;37m"; # Bright White Foreground
#my $yellow_bg = "\033[43m";  # Yellow background
my $yellow_bg = "\033[48;5;229m";  # Very pale yellow background
#my $yellow_bg = "\033[48;5;222m";  # Light gold background
#my $yellow_bg = "\033[48;5;216m";  # Pastel yellow background
my $reset_all    = "\033[0m";  # Reset ALL attributes

# Create new keys with -HL and yellow background
foreach my $key (keys %colors) {
    next if $key eq 'NC';  # Skip NC
    my $new_key = "$key-HL";
    #$colors{$new_key} = "$colors{$key}$yellow_bg";			# Apply a yellow background on top of the existing FG color
    
   my $original_fg_color = $colors{$key}; # Get original foreground

    # Extract the original colour code from the FG code
    $original_fg_color =~ s/^\e\[(.*?)m/$1/g;

    my $bg_color_256;
    if ($original_fg_color eq "0;31") {    # Red
        $bg_color_256 = "196";            # 256-color code for Red
    } elsif ($original_fg_color eq "0;33") { # Yellow
        $bg_color_256 = "226";            # 256-color code for Yellow
    } elsif ($original_fg_color eq "0;32") { # Green
        $bg_color_256 = "46";             # 256-color code for Green
    } elsif ($original_fg_color eq "0;34") { # Blue
        $bg_color_256 = "21";             # 256-color code for Blue
    } elsif ($original_fg_color eq "0;35") { # Magenta
        $bg_color_256 = "201";            # 256-color code for Magenta
    } else {
        $bg_color_256 = "0";              # Black background as default
    }

    #$colors{$new_key} = "\033[48;5;${bg_color_256}m${white_fg}";
    $colors{$new_key} = "$colors{$key}\033[48;5;${bg_color_256}m";
  #  print "$original_fg_color\n";
}


## SUBS ##

sub print_title {
    my $title = <<"END";
\033[0;37m
\033[90m\033[109m
──────────────────────────────────────────────────────────────────────────────────────────────

   ,:: ltl ::' log timeline  --  by Greg Eva // geva\@ptc.com // gregeva\@gmail.com

──────────────────────────────────────────────────────────────────────────────────────────────
\033[0m
END
    print $title;
    return;
}

sub print_usage {
    my ( $error_reason ) = @_;
    print "Usage: $0 [--bucket-size|-bs <time block>] [--pause|-p] [--start|-st <YYYY-MM-DD HH:MM:SS>] [--end|-et <HH:MM>] [--exlude|-e <RegEx>] [--include|-i <RegEx>] [--highlight|-h <RegEx>] [--seconds|-s] [--milliseconds|-ms] [--omit-values|-ov] [--omit-empty|-oe] [--omit-summary|-os] [--duration-min|-dmin <value>] [--duration-max|-dmax <value>] [--bytes-min|-bmin <value>] [--bytes-max|-bmax <value>] [--version|-v] <file1> <file2> ...\n";
    print "\n  Error: $error_reason\n";
    return;
}

sub print_version {
    print "Version: $version_number\n\n";
    return;
}

# Function to get current memory usage
sub get_memory_usage {
    my $t = Proc::ProcessTable->new();
    my ($memory_usage) = map { $_->rss } grep { $_->pid == $$ } @{$t->table};
    return $memory_usage;
}

sub convert_bytes {
    my ($input_value, $input_unit) = @_;
    my ($value, $unit);

    if( defined( $input_unit ) ) {
        $value = $input_value;
        $unit = $input_unit;
    } else {
        ( $value, $unit ) = $input_value =~ /^(\d+)[ ]?(\w+)$/;
    }

    my %units = (
        'B'  => 1,
        'b'  => 1,
        'kB' => 1024,
        'KB' => 1024,
        'k' => 1024,
        'K' => 1024,
        'MB' => 1024**2,
        'M' => 1024**2,
        'GB' => 1024**3,
        'G' => 1024**3,
        'TB' => 1024**4,
        'T' => 1024**4,
    );

    # Convert input value to bytes
    my $bytes = $value * $units{$unit};

    return $bytes;
}

sub format_bytes {
    my ($value, $unit) = @_;
    my %units = (
        'B'  => 1,
        'kB' => 1024,
        'MB' => 1024**2,
        'GB' => 1024**3,
        'TB' => 1024**4,
    );

    # Convert input value to bytes
    my $bytes = $value * $units{$unit};

    # Determine the most relevant unit
    my @unit_order = ('B', 'kB', 'MB', 'GB', 'TB');
    my $formatted_value = $bytes;
    my $formatted_unit = 'B';

    foreach my $u (@unit_order) {
        if ($bytes >= $units{$u}) {
            $formatted_value = $bytes / $units{$u};
            $formatted_unit = $u;
        } else {
            last;
        }
    }

    # Format the value to 1 decimal place
    $formatted_value = sprintf("%.1f", $formatted_value);

    return "$formatted_value $formatted_unit";
}

sub format_number {
    my ($value, $space) = @_;
    my %units = (
        '1'  => 1,
        'k' => 1000,
        'Mil' => 1000**2,
        'Bil' => 1000**3,
        'Tril' => 1000**4,
    );


    # Determine the most relevant unit
    my @unit_order = ('1', 'k', 'Mil', 'Bil', 'Tril');
    my $formatted_value = $value;
    my $formatted_unit = '';

    foreach my $u (@unit_order) {
        if ($value >= $units{$u}) {
            $formatted_value = $value / $units{$u};
            $formatted_unit = $u;
        } else {
            last;
        }
    }

    # Format the value to 1 decimal place
    $formatted_value = sprintf("%.1f%s%s", $formatted_value, defined($space) ? " " : "", $formatted_unit eq "1" ? "" : $formatted_unit );
    $formatted_value =~ s/\.0//;

    return $formatted_value;
}

sub format_time {
    my ($value, $unit, $format, $space) = @_;
    my %units = (
        'us' => 1,                      # Microseconds
        'ms' => 1000,                   # Milliseconds
        's'  => 1000000,                # Seconds
        'm'  => 60 * 1000000,           # Minutes
        'h'  => 60 * 60 * 1000000,      # Hours
        'D'  => 24 * 60 * 60 * 1000000, # Days
    );

    my %unit_names = (
        'us' => { short => 'us', medium => 'usec', long => 'microseconds' },
        'ms' => { short => 'ms', medium => 'msec', long => 'milliseconds' },
        's'  => { short => 's',  medium => 'sec',      long => 'seconds' },
        'm'  => { short => 'm',  medium => 'min',      long => 'minutes' },
        'h'  => { short => 'h',  medium => 'hr',       long => 'hours' },
        'D'  => { short => 'd',  medium => 'day',      long => 'days' },
    );

    $format = "short" if !defined $format;

    # Convert input value to microseconds
    my $microseconds = $value * $units{$unit};

    # Determine the most relevant unit
    my @unit_order = ('us', 'ms', 's', 'm', 'h', 'D');
    my $formatted_value = $microseconds;
    my $formatted_unit = 'us';

    foreach my $u (@unit_order) {
        if ($microseconds >= $units{$u}) {
            $formatted_value = $microseconds / $units{$u};
            $formatted_unit = $u;
        } else {
            last;
        }
    }

    # Format the value to 1 decimal place
    $formatted_value = sprintf("%.1f", $formatted_value);

    # Get the appropriate unit name based on the format
    my $unit_name = $unit_names{$formatted_unit}{$format};
    $unit_name = " " . $unit_name if defined( $space );

    return "$formatted_value$unit_name";
}

sub adapt_to_command_line_options {
    # Get command-line options
    GetOptions(
        'bucket-size|bs=i' => \$bucket_size_minutes,
        'pause|p' => \$pause_output,
        'start|st=s' => \$range_start,
        'end|et=s' => \$range_end,
        'exclude|e=s' => \$exclude_regex,
        'include|i=s' => \$include_regex,
        'highlight|h=s' => \$highlight_regex,
        'top-messages|n=i' => \$top_n_messages,
        'omit-values|ov' => \$omit_values,
        'omit-empty|oe' => \$omit_empty,
        'omit-summary|os' => \$omit_summary,
        'omit-rate|or' => \$omit_rate,
        'seconds|s' => \$print_seconds,
        'milliseconds|ms' => \$print_milliseconds,
        'version|v' => \$print_version,
        'duration-min|dmin=i' => \$filter_duration_min,
        'duration-max|dmax=i' => \$filter_duration_max,
        'bytes-min|bmin=i' => \$filter_bytes_min,
        'bytes-max|bmax=i' => \$filter_bytes_max
    ) or die print_usage( "required options not provided" ); 

    $range{'start'} = $range_start if defined( $range_start );
    $range{'end'} = $range_end if defined(  $range_end );

    if( $print_version ) {
        print_version();
        exit;
    }

    # Ensure at least one file is provided
    @in_files = @ARGV;
    die print_usage( "unable to open any files" ) unless @in_files;

# Should include cleaner handling of possible problems with entering command line options
#eval {
#    die "Something bad happened";
#};
#if ($@) {
#    # Handle the error here
#    print "Caught the error: $@";
#}
    $output_timestamp_format .= ":%S" if $print_seconds || $print_milliseconds;
    #$bucket_size_seconds = $print_seconds ? $bucket_size_minutes : $bucket_size_minutes * 60;		# if they say they want milliseconds, we're going to assume that their bucket sizes are in seconds instead
    if( $print_seconds ) {
        $bucket_size_seconds = $bucket_size_minutes;
    } elsif( $print_milliseconds ) {
        $bucket_size_seconds = $bucket_size_minutes / 1000;
    } else {
        $bucket_size_seconds = $bucket_size_minutes * 60;
    }

    return;
}

# Parse various possible formats for input of start and end times and set associated filter variables
sub calculate_start_end_filter_timestamps {
    my ( $log_time ) = @_;
    my $log_date = $log_time->epoch() - ( $log_time->hour * ( 60 * 60 ) + $log_time->minute * 60 + $log_time->second );

    foreach my $key (keys %range) {
        my $value = $range{$key};  # Get the value (either $range_start or $range_end)
        next unless length( $range{$key} ) > 0;
        my $epoch_value;  # Variable to store the epoch time

        # Convert timestamp to epoch seconds using Time::Piece -- WARNING -- use of strptime can cause timezone problems, it appears to work here as I've manually set TZ to UTC on input
        if ( $value =~ /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/ ) {
            $epoch_value = Time::Piece->strptime( $value, "%Y-%m-%d %H:%M:%S" )->epoch;
        } elsif ( $value =~ /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}/ ) {
            $epoch_value = Time::Piece->strptime( $value, "%Y-%m-%d %H:%M" )->epoch;
        } elsif ( $value =~ /^\d{4}-\d{2}-\d{2}/ ) {
            $epoch_value = Time::Piece->strptime( $value, "%Y-%m-%d" )->epoch;
        } elsif ( $value =~ /^\d{2}:\d{2}:\d{2}/ ) {
            $epoch_value = $log_date + Time::Piece->strptime( $value, "%H:%M:%S" )->epoch;
        } elsif ( $value =~ /^\d{2}:\d{2}/ ) {
            $epoch_value = $log_date + Time::Piece->strptime( $value, "%H:%M" )->epoch;
        } else {
            print "Warning: unhandled date/time format - option not taken into account\n";
        }

        #print "Epoch value in seconds: $epoch_value\n";
        $range_epoch{$key} = $epoch_value if defined( $epoch_value );  # Store the epoch value in the hash
    }
    return 1;
}

sub adapt_to_terminal_settings {
    $terminal_width //= 80; # Default to 80 if terminal width cannot be determined
    $terminal_height //= 24; # Default to 24 if terminal height cannot be determined

    # Auto-adjust the bucket size based on the terminal height (larger terminal can handle more rows)
    if( $terminal_height <= 24 ) {
        $bucket_size_minutes = 60;
    } elsif( $terminal_height <= 45 ) {
        $bucket_size_minutes = 30;
    } elsif( $terminal_height <= 65 ) {
        $bucket_size_minutes = 10;
    } elsif( $terminal_height <= 85 ) {
        $bucket_size_minutes = 5;
    } elsif( $terminal_height > 85 ) {
        $bucket_size_minutes = 1;
    } else {
        $bucket_size_minutes = 60;
    }
    #print "Terminal is: $terminal_width x $terminal_height -- Bucket size: $bucket_size_minutes\n";

    $max_log_message_length = $terminal_width;		# this is the max that we can print without wrapping, depends on the summary table width, and terminal width 
    return;
}

sub pause_for_keypress {
    my ($prompt) = @_;  # Get the optional prompt message
    $prompt = "Press any key to continue (or Q to quit)..." unless defined $prompt;
    print "\033[0;44m$prompt\033[0m";

    ReadMode 4;  # Turn off line buffering
    my $key = ReadKey(0);
    ReadMode 0;  # Restore normal input mode

    if (defined $key) {
        if ($key eq "q" || $key eq "Q") {
            print "\r";
            print " " x length( $prompt );
            print "\r\033[0;35mExiting program.\033[0m\n";
            exit 0;
        } else {
            print "\r";
            print " " x length( $prompt );
            print "\r";
            return 1;  # Return a value indicating "continue"
        }
    } else {
        print "\r";
        print " " x length( $prompt );
        print "\r";
        return 1;
    }
}

# Parse logs, bucket by time, and count log levels
sub read_and_process_logs {
    # BUG: this should be able to take multiple files as inputs using * but it doesn't work, same for including multiple files
    foreach my $in_file (@in_files) {
        open my $fh, '<', $in_file or die "Cannot open file: $in_file";
        my $line_number = 0;
        my $range_filter_initialized = 0;
        my %month_map = ( Jan => 1, Feb => 2, Mar => 3, Apr => 4, May => 5, Jun => 6, Jul => 7, Aug => 8, Sep => 9, Oct => 10, Nov => 11, Dec => 12 );

        while (<$fh>) {
            $line_number++;
            my ( $timestamp_str, $log_level, $category_bucket, $object, $instance, $user, $platform, $thread, $message ) = ("") x 9;
            my ( $is_line_match, $is_access_log, $match_type, $status_code, $bytes, $duration, $heap_from, $heap_to, $heap_size ) = 0;
            my $timestamp;
            $total_lines_read++;

#($timestamp_str, $category_bucket, $heap_from, $heap_to, $heap_size, $duration) = (undef, undef, undef, undef, undef, undef);

            if ($line_number % 997 == 0) {	# only print processing status update every X lines processed
                printf("\rProcessing line %d in file %s (%d overall)", $line_number, $in_file, $total_lines_read);
                $| = 1; # Flush output
            }

            if ($line_number % 100000 == 0) {	# only collect memory in use around every 100000 lines processed
                $current_memory_usage = get_memory_usage();								# track maximum memory usage
                if ($current_memory_usage > $max_memory_usage) {
                    $max_memory_usage = $current_memory_usage;
                }
            }

            if ( ($timestamp_str, $category_bucket, $object, $instance, $user, undef, $platform, $thread, $message ) = $_ =~ /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3})\+\d{4} \[L: ([^\]]*)\] \[O: ([^\]]*)] \[I: ([^\]]*)] \[U: ([^\]]*)] \[S: ([^\]]*)] \[P: ([^\]]*)] \[T: ([^\]]*)] (.*)/) {
                $is_line_match = 1;
                $match_type = 1;			# this is matching ThingWorx standard log format 2025-02-04 12:05:57.481+0000 [L: DEBUG] 
                $thread =~ s/(.*)-\d+$/$1/;
            } elsif ( ($timestamp_str, $category_bucket) = $_ =~ /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3})\+\d{4} \[L: ([^\]]*)\]/) {
                $is_line_match = 1;
                $match_type = 1;			# this is matching ThingWorx standard log format 2025-02-04 12:05:57.481+0000 [L: DEBUG] 
            } elsif ( ($timestamp_str, $category_bucket ) = $_ =~ /^[\[]?(\d{4}-\d{2}-\d{2}[ T]\d{2}:\d{2}:\d{2}\.\d{3}).*? \[[L: ]*([^\]]*)\]/ ) {
                $is_line_match = 1;
                $match_type = 2;			# this is matching RAC client log format [2025-02-04T12:06:22.784] [TRACE]
                $timestamp_str =~ tr/T/ /;
            } elsif ( (undef, $timestamp_str, $message, $category_bucket, $bytes, $duration) = $_ =~ /^(.+? ){3}[\[]([^\]]+)[\]] "([^"]+)" (\d{3}) (\d+) (\d+)/ ) {
                $is_line_match = 1;
                $match_type = 3;			# this is matching Tomcat access log format with service execution time 43.52.82.172 - - [02/Feb/2025:00:00:11 +0000] "GET /Thingworx/Metrics?x-thingworx-session=false HTTP/1.1" 200 17626 295
                $is_access_log = 1;
                $status_code = $category_bucket;
                $category_bucket =~ s/(\d)\d{2}/$1xx/;	# bucket HTTP status codes into their primary families
                $timestamp_str =~ s/ \+\d{4}$//;	# chop off the timezone offset
                #$message =~ s/\?.+$//;			# chop off the query string from the URI
#print "$message -- $_";
            } elsif ( (undef, $timestamp_str, $message, $category_bucket, $bytes) = $_ =~ /^(.+? ){3}[\[]([^\]]+)[\]] "([^"]+)" (\d{3}) (\d+)/ ) {
                $is_line_match = 1;
                $match_type = 4;			# this is matching Tomcat access log format with service execution time 43.52.82.172 - - [02/Feb/2025:00:00:11 +0000] "GET /Thingworx/Metrics?x-thingworx-session=false HTTP/1.1" 200 17626
                					# this is matching Nginx ingress access log format 3.133.31.181 - - [18/Nov/2024:14:19:55 +0000] "GET / HTTP/1.1" 404 431 "-" "WizDynamicScanner/1.0"
                $is_access_log = 1;
                $status_code = $category_bucket;
                $category_bucket =~ s/(\d)\d{2}/$1xx/;	# bucket HTTP status codes into their primary families
                $timestamp_str =~ s/ \+\d{4}$//;	# chop off the timezone offset
                #$message =~ s/\?.+$//;			# chop off the query string from the URI
            } elsif ( ($timestamp_str, $category_bucket) = $_ =~ /^{"\@timestamp":"([^"]*).*"level":"([^"]*)/ ) {
                $is_line_match = 1;
                $match_type = 5;			# this matches Connection Server JSON formatted logs : {"@timestamp":"2025-02-02T21:03:06.725+00:00","@version":1,"message":"Error encountered, closing WebSocket: endpointId=2608459","logger_name":"com.thingworx.connectionserver.alwayson.AbstractClientEndpoint","thread_name":"vert.x-eventloop-thread-16","level":"WARN","level_value":30000,"stack_trace":"io.vertx.core.http.HttpClosedException: Connection was closed\n"}
                $timestamp_str =~ s/\+\d{2}:\d{2}$//;	# chop off the timezone offset
                $timestamp_str =~ tr/T/ /;
            } elsif ( ( $timestamp_str, $category_bucket, $message, $heap_from, $heap_to, $heap_size, $duration ) = $_ =~ /^[\[]?(\d{4}-\d{2}-\d{2}[ T]\d{2}:\d{2}:\d{2}\.\d{3})[+-]\d{4}.*?\[info\]\[gc\s*\] GC\(\d+\) (.+?) (\(.+?\)) (\d[^-]+)->(\d[^(]+)\((\d[^)]+)\) (\d.*)ms/ ) {
                $is_line_match = 1;
                $match_type = 6;			# this matches Java GC log info level pause
                $is_access_log = 1;			# need this to have statistics calculated
                $default_chart_block = 'C' unless $default_chart_block ne 'C';

                $bytes = convert_bytes( $heap_from ) - convert_bytes( $heap_to );
                $bytes = $bytes < 0 ? 0 : $bytes;
            }

#print "Thread: $thread   Object: $object   Message: $message\n";

            #print "\033[0;32m[$timestamp_str|$category_bucket] [$is_line_match/$match_type] \033[0m$_";
            #$| = 1; # Flush output

            if( $is_line_match ) {
                $bytes = 0 if( defined( $bytes ) && $bytes < 0 );

                unless (grep { $_ eq $category_bucket } @log_levels) {				# this condition importantly only continues if the read/parsed log category is one of the ones defined
                    next;
                } elsif( $match_type == 1 || $match_type == 2 || $match_type == 5 || $match_type == 6 ) {
                    $timestamp = DateTime->new(
                        year      => substr($timestamp_str, 0, 4),
                        month     => substr($timestamp_str, 5, 2),
                        day       => substr($timestamp_str, 8, 2),
                        hour      => substr($timestamp_str, 11, 2),
                        minute    => substr($timestamp_str, 14, 2),
                        second    => substr($timestamp_str, 17, 2),
                        time_zone => 'UTC',
                    );
                } elsif( $match_type == 3 || $match_type == 4 ) {
                    my ($day, $month_str, $year, $hour, $minute, $second) = $timestamp_str =~ m/(\d{2})\/([A-Za-z]+)\/(\d{4}):(\d{2}):(\d{2}):(\d{2})/;
                    my $month = $month_map{$month_str};
                    $timestamp = DateTime->new(
                        year      => $year,
                        month     => $month,
                        day       => $day,
                        hour      => $hour,
                        minute    => $minute,
                        second    => $second,
                        time_zone => 'UTC',
                    );

#                    print "\033[0;35m[%d]\033[0m", $timestamp->epoch();
#                    $| = 1; # Flush output
                }

                $range_filter_initialized = calculate_start_end_filter_timestamps( $timestamp ) unless $range_filter_initialized;

                # a number of conditions determine if this read row should be skipped
                next if( $timestamp->epoch() < $range_epoch{'start'} || $timestamp->epoch() >= $range_epoch{'end'} );
                next if( defined( $exclude_regex ) && /$exclude_regex/ );
                next if( defined( $include_regex ) && !/$include_regex/ );
                next if( defined( $filter_duration_min ) && $duration < $filter_duration_min );		# skip if duration value is below specified minimum filter
                next if( defined( $filter_duration_max ) && $duration > $filter_duration_max );		# skip if duration value is above specified maximum filter
                next if( defined( $filter_bytes_min ) && $bytes < $filter_bytes_min );			# skip if bytes value is below specified minimum filter
                next if( defined( $filter_bytes_max ) && $bytes > $filter_bytes_max );			# skip if bytes value is above specified maximum filter

                # determine if this line should be highlighted
                $category_bucket .= '-HL' if( defined( $highlight_regex ) && /$highlight_regex/ );

                # sets earliest and latest timestamp values being displayed (after the range filtering selection)
                $output_timestamp_min = $timestamp->epoch() if $output_timestamp_min == 0 || $output_timestamp_min > $timestamp->epoch();
                $output_timestamp_max = $timestamp->epoch() if $output_timestamp_max == 0 || $output_timestamp_max < $timestamp->epoch();

                my $bucket = int($timestamp->epoch() / $bucket_size_seconds) * $bucket_size_seconds;

                $log_counts{$bucket}{$category_bucket}{count}++;

                if( defined( $message ) ) {
                    my $log_key = "";
                    my $log_level = $category_bucket;
                    my $category = "";
                    $log_level =~ s/-HL$//;

                    if( defined($thread) && defined($object) ) {					# ThingWorx log line parsed and usable for additional analysis
                        my $truncated_thread = substr( $thread, 0, 20 );
                        my $max_object_length = 25;
                        my $truncated_object = substr( $object, length($object) > $max_object_length ? length($object)-$max_object_length : 0, $max_object_length );
                        $log_key = substr("[$log_level] [$truncated_thread] [$truncated_object] $message", 0, $max_log_message_length);
                    } elsif( defined( $thread ) ) {
                        my $truncated_thread = substr( $thread, 0, 20 );
                        $log_key = substr("[$log_level] [$truncated_thread] $message", 0, $max_log_message_length);
                    } else {
                        $log_key = substr("[$log_level] $message", 0, $max_log_message_length);
                    }

                    if( $category_bucket =~ /-HL$/ ) {
                        $category = 'highlight';
                    } else {
                        $category = 'plain';
                    }

                    #$log_messages{$category}{$log_key}{count} //= 0;
                    #$log_messages{$category}{$log_key}{count} = 0 if !defined $log_messages{$category}{$log_key}{count};
                    $log_messages{$category}{$log_key}{count}++;

                    if( $is_access_log ) {
                        # Calculate the log scale bucket for the duration
                        my $duration_bucket = log_bucket($duration, $log_base);

                        # Ensure duration and bytes are defined
                        $duration = 0 if !defined($duration);
                        $bytes = 0 if !defined($bytes);

                        # Initialize the hash if not already done
                        $log_messages{$category}{$log_key}{$duration_bucket} //= {
                            count => 0,
                            total_bytes => 0,
                            total_duration => 0,
                            sum_of_squares => 0,
                            durations => [],
                        };
                        # Increment the count for the duration bucket
                        $log_messages{$category}{$log_key}{$duration_bucket}{count}++;

                        # Accumulate the total duration and bytes
                        $log_messages{$category}{$log_key}{$duration_bucket}{total_duration} += $duration;
                        $log_messages{$category}{$log_key}{$duration_bucket}{total_bytes} += $bytes;

                        # Accumulate the sum of squares for variance calculation
                        $log_messages{$category}{$log_key}{$duration_bucket}{sum_of_squares} += $duration ** 2;
                        push @{$log_messages{$category}{$log_key}{$duration_bucket}{durations}}, $duration;
                    }
                }

                if( $is_access_log ) {
                    $print_durations = 1 if $print_durations != 1;

# TO DO - this is a temporary hack to turn off empty time window support as it does not presently work with statistical calculations
#                    $omit_empty = 1 if !defined( $omit_empty ) || $omit_empty != 1;

                    ## STATISTICAL DATA CAPTURE ##
                    #print "$duration -- $_";
                    my $duration_bucket = log_bucket($duration, $log_base);
                    $duration = 0 if !defined( $duration );
                    $bytes = 0 if !defined( $bytes );
    
                    # Initialize the hash if not already done
                    $log_analysis{$bucket}{$duration_bucket} //= {
                        count => 0,
                        total_bytes => 0,
                        total_duration => 0,
                        sum_of_squares => 0,
                        durations => [],
                    };
    
                    # Update the hash with the new data
                    $log_analysis{$bucket}{$duration_bucket}{count}++;
                    $log_analysis{$bucket}{$duration_bucket}{total_duration} += $duration;
                    $log_analysis{$bucket}{$duration_bucket}{total_bytes} += $bytes;
                    $log_analysis{$bucket}{$duration_bucket}{sum_of_squares} += $duration ** 2;
                    push @{$log_analysis{$bucket}{$duration_bucket}{durations}}, $duration;

                  #  printf "\033[0;35m[duration: %d] [bytes: %d]\033[0m\n", $duration, $bytes;
                   # printf "\033[0;35m[status: %s] [duration: %d] [bytes: %d]\033[0m\n", $category_bucket, $log_counts{$bucket}{duration}, $log_counts{$bucket}{bytes};
                  #  $| = 1; # Flush output
                }
            }
        }
        close $fh;

        print "\r" . " " x ($terminal_width - 1) . "\r";		# clear the line of progress messages when moving on to the next file
    }
    print "\r$colors{'bright-green'}Processing completed.$colors{'NC'}";
    print " " x ( $terminal_width - length( "Processing completed." ) );
    print "\n";

    return;
}

sub calculate_all_statistics {

    print "\rCalculating statistics...";

    foreach my $bucket (sort { $a <=> $b } keys %log_analysis) {
        my $aggregated_data = {
            count => 0,
            total_duration => 0,
            total_bytes => 0,
            sum_of_squares => 0,
            durations => [],
        };

        $current_memory_usage = get_memory_usage();								# track maximum memory usage
        if ($current_memory_usage > $max_memory_usage) {
            $max_memory_usage = $current_memory_usage;
        }
    
        foreach my $duration_bucket (keys %{$log_analysis{$bucket}}) {
            my $bucket_data = $log_analysis{$bucket}{$duration_bucket};

            next if !defined( $bucket_data->{count} );

            $aggregated_data->{count} += $bucket_data->{count};
            $aggregated_data->{total_duration} += $bucket_data->{total_duration};
            $aggregated_data->{total_bytes} += $bucket_data->{total_bytes};
            $aggregated_data->{sum_of_squares} += $bucket_data->{sum_of_squares};
            push @{$aggregated_data->{durations}}, @{$bucket_data->{durations}};

            # free up the memory from the data structure as it is no longer needed
            undef $log_analysis{$bucket}{$duration_bucket}{durations};
            delete $log_analysis{$bucket}{$duration_bucket}{durations};
        }
    
        my ($mean, $p1, $p50, $p90, $p95, $p99, $std_dev, $cv) = calculate_statistics($aggregated_data);

        $log_stats{$bucket} = {
            count => $aggregated_data->{count},
            bytes => $aggregated_data->{total_bytes},
            mean => $mean,
            p1  => $p1,
            p50 => $p50,
            p90 => $p90,
            p95 => $p95,
            p99 => $p99,
            std_dev => $std_dev,
            cv => $cv,
            z_score => 'N/A'
        };
    
        # Calculate rolling mean and std_dev
        my $rolling_mean = 0;
        my $rolling_sum_of_squares = 0;
        my $rolling_count = 0;
        foreach my $prev_bucket (@rolling_window) {
            $rolling_mean += $prev_bucket->{mean};
            $rolling_sum_of_squares += $prev_bucket->{sum_of_squares};
            $rolling_count++;
        }
        if ($rolling_count > 0) {
            $rolling_mean /= $rolling_count;
            my $rolling_variance = ($rolling_sum_of_squares / $rolling_count) - ($rolling_mean ** 2);
            my $rolling_std_dev = sqrt($rolling_variance);
            my $z_score = calculate_z_score($mean, $rolling_mean, $rolling_std_dev);

    #        print "Time Bucket: $bucket\n";
    #        print "Count: $aggregated_data->{count}, Bytes: $aggregated_data->{total_bytes}, Mean: $mean, P1: $p1, P50: $p50, P90: $p90, P95: $p95, P99: $p99, Std Dev: $std_dev, Coefficient of Variance: $cv, Z-score: $z_score\n";
	    $log_stats{$bucket}{z_score} = $z_score;
        } else {

    #        print "Time Bucket: $bucket\n";
    #        print "Count: $aggregated_data->{count}, Bytes: $aggregated_data->{total_bytes}, Mean: $mean, P1: $p1, P50: $p50, P90: $p90, P95: $p95, P99: $p99, Std Dev: $std_dev, Coefficient of Variance: $cv, Z-score: N/A\n";
        }

        # Update rolling window logic
        push @rolling_window, { mean => $mean, sum_of_squares => $aggregated_data->{sum_of_squares} };
        shift @rolling_window if @rolling_window > $rolling_window_size;

    }

#    # Calculate and print overall statistics for the entire dataset
#    my $overall_stats = {
#        count => 0,
#        total_duration => 0,
#        sum_of_squares => 0,
#        durations => [],
#    };
#
#    foreach my $bucket (keys %log_analysis) {
#        foreach my $duration_bucket (keys %{$log_analysis{$bucket}}) {
#            my $bucket_data = $log_analysis{$bucket}{$duration_bucket};
#            $overall_stats->{count} += $bucket_data->{count};
#            $overall_stats->{total_duration} += $bucket_data->{total_duration};
#            $overall_stats->{sum_of_squares} += $bucket_data->{sum_of_squares};
#            push @{$overall_stats->{durations}}, @{$bucket_data->{durations}};
#
#            # free up the memory from the data structure as it is no longer needed
#            undef $log_analysis{$bucket}{$duration_bucket}{durations};
#            delete $log_analysis{$bucket}{$duration_bucket}{durations};
#        }
#    }
#
#    my ($overall_mean, $overall_p1, $overall_p50, $overall_p90, $overall_p95, $overall_p99, $overall_std_dev, $overall_cv) = calculate_statistics($overall_stats);
#    print "Overall Statistics:\n";
#    print "Count: $overall_stats->{count}, Mean: $overall_mean, 90th Percentile: $overall_p90, 95th Percentile: $overall_p95, Std Dev: $overall_std_dev, Coefficient of Variance: $overall_cv\n";
#

## STATS FOR TOP LOG MESSAGES ##

    if( $print_durations ) {
        foreach my $category (keys %log_messages) {
            # Collect and sort the log keys based on the count within each log_key
            my @sorted_log_keys = sort {
                my $count_a = $log_messages{$category}{$a}{count} // 0;
                my $count_b = $log_messages{$category}{$b}{count} // 0;
                $count_b <=> $count_a;
            } keys %{$log_messages{$category}};
    
            # Process only the top N log keys
            #my @top_keys = @sorted_log_keys[0 .. $top_n_messages - 1];
            my @top_keys = @sorted_log_keys[0 .. min($#sorted_log_keys, $top_n_messages - 1)]; 

            foreach my $log_key (@top_keys) {
                my $aggregated_data = {
                    count => 0,
                    total_duration => 0,
                    total_bytes => 0,
                    sum_of_squares => 0,
                    durations => [],
                };

                $current_memory_usage = get_memory_usage();								# track maximum memory usage
                if ($current_memory_usage > $max_memory_usage) {
                    $max_memory_usage = $current_memory_usage;
                }
    
                foreach my $duration_bucket (sort {$a <=> $b} grep { $_ ne 'count' } keys %{$log_messages{$category}{$log_key}}) {
                    my $message_data = $log_messages{$category}{$log_key}{$duration_bucket};
    
                    next if !defined( $message_data->{count} );
    
                    $aggregated_data->{count} += $message_data->{count};
                    $aggregated_data->{total_duration} += $message_data->{total_duration};
                    $aggregated_data->{total_bytes} += $message_data->{total_bytes};
                    $aggregated_data->{sum_of_squares} += $message_data->{sum_of_squares};
                    push @{$aggregated_data->{durations}}, @{$message_data->{durations}};

                    # free up the memory from the data structure as it is no longer needed
                    undef $log_messages{$category}{$log_key}{$duration_bucket}{durations};
                    delete $log_messages{$category}{$log_key}{$duration_bucket}{durations};
                }
    
                my ($mean, $p1, $p50, $p90, $p95, $p99, $std_dev, $cv) = calculate_statistics($aggregated_data);
        
                #print "--- $log_key ---\n     Count: $aggregated_data->{count}, Mean: $mean, P1: $p1, P50: $p50, P90: $p90, P95: $p95, P99: $p99, Std Dev: $std_dev, Coefficient of Variance: $cv, Z-score: N/A\n";
    
                $log_messages{$category}{$log_key}{p1} = $p1;
                $log_messages{$category}{$log_key}{p50} = $p50;
                $log_messages{$category}{$log_key}{p90} = $p90;
                $log_messages{$category}{$log_key}{p95} = $p95;
                $log_messages{$category}{$log_key}{p99} = $p99;
                $log_messages{$category}{$log_key}{cv} = $cv;
                $log_messages{$category}{$log_key}{total_duration} = format_time( $aggregated_data->{total_duration}, 'ms', 'medium', 'space' );

            }
        }
    }

    print "\r" . " " x ($terminal_width - 1) . "\r";		# clear the line of progress messages when moving on to the next file
    print "\r$colors{'bright-green'}Calculating statistics completed.$colors{'NC'}";
    print " " x ( $terminal_width - length( "Calculating statistics completed." ) );
    print "\n";

    return;
}

# Function to calculate the log scale bucket
sub log_bucket {
    my ($value, $base) = @_;
    $value = 0 if !defined( $value );
    return $value > 0 ? floor(log($value) / log($base)) : 0;
}

# Function to calculate Z-score
sub calculate_z_score {
    my ($current_mean, $rolling_mean, $rolling_std_dev) = @_;
    return 'N/A' if $rolling_std_dev == 0;
    return sprintf("%.2f", ($current_mean - $rolling_mean) / $rolling_std_dev);
}

# Function to calculate statistical metrics
sub calculate_statistics {
    my ($bucket_data) = @_;
    my $count = $bucket_data->{count};
    return unless $count > 0;
    
    my $mean = int($bucket_data->{total_duration} / $count);
    my $variance = ($bucket_data->{sum_of_squares} / $count) - ($mean ** 2);
    my $std_dev = sqrt($variance);
    my $cv = $mean != 0 ? sprintf("%.2f", $std_dev / $mean) : 'N/A';

    my @sorted = sort { $a <=> $b } @{$bucket_data->{durations}};
    my $p1 = int($sorted[int($count * 0.01)]);
    my $p50 = int($sorted[int($count * 0.5)]);
    my $p90 = int($sorted[int($count * 0.9)]);
    my $p95 = int($sorted[int($count * 0.95)]);
    my $p99 = int($sorted[int($count * 0.99)]);
    
    return ($mean, $p1, $p50, $p90, $p95, $p99, $std_dev, $cv);
}

sub initialize_empty_time_windows {

    # Go through all of the buckets between the earliest and latest times and ensure that they have empty data to print time buckets with no data
    unless( $omit_empty ) {
        my $start_bucket = int($output_timestamp_min / $bucket_size_seconds) * $bucket_size_seconds;

        print "\rInitializing empty time windows...";

        for (my $bucket = $start_bucket; $bucket <= $output_timestamp_max; $bucket += $bucket_size_seconds) {
            $log_counts{$bucket}{'empty'}{'count'} = 0;

                    # Initialize the hash if not already done
#                    $log_analysis{$bucket}{$duration_bucket} //= {
#                        count => 0,
#                        total_bytes => 0,
#                        total_duration => 0,
#                        sum_of_squares => 0,
#                        durations => [],
#                    };
        }

        print "\r" . " " x ($terminal_width - 1) . "\r";		# clear the line of progress messages when moving on to the next file
        print "\r$colors{'bright-green'}Initializing empty time windows completed.$colors{'NC'}";
        print " " x ( $terminal_width - length( "Initializing empty time windows completed." ) );
        print "\n";
    }

    return;
}

sub normalize_data_for_output {
    # Determine the maximum total log messages for any time window
    my $max_total_count = 0;
    my $max_total_bytes = 0;

    print "\rScaling and normalizing data...";

    foreach my $bucket (keys %log_counts) {
        my $total_count = 0;
        my $total_bytes = $log_stats{$bucket}{bytes} if $print_durations;
        my $error_count = 0;

        foreach my $category_bucket (keys %{$log_counts{$bucket}}) {
            my $count = $log_counts{$bucket}{$category_bucket}{count};
            next unless $count > 0 && $category_bucket !~ /^empty|err-rate|msg-rate$/; 			# don't include the empty bucket who's purpose is to normalize the buckets represented
            #$total_count += $log_counts{$bucket}{$category_bucket}{count};
            $total_count += $count;
            $error_count += $count if $category_bucket =~ /^ERROR|5xx|4xx$/i;
        }

        # this part takes the time windows error and message counts and converts them to a per minute rate
        unless( defined( $omit_rate ) && $omit_rate ) {
            $log_counts{$bucket}{'err-rate'}{count} = $error_count / $bucket_size_seconds * 60;
            $log_counts{$bucket}{'msg-rate'}{count} = $total_count / $bucket_size_seconds * 60;
        }

        $max_total_count = $total_count if $total_count > $max_total_count;
        $max_total_bytes = $total_bytes if ( defined $total_bytes && $print_durations && $total_bytes > $max_total_bytes );
    }


    # Calculate the maximum length of log level titles and counts
#    if( !$omit_values ) {
        foreach my $bucket (keys %log_counts) {

#my $bucket_time_str = strftime($output_timestamp_format, gmtime($bucket));
#print "$bucket_time_str : ";

            my $bucket_legend_length = 0;
            foreach my $category_bucket (keys %{$log_counts{$bucket}}) {
                my $count = $log_counts{$bucket}{$category_bucket}{count};
                my $title_length = 0;
                next unless ( $count > 0 || $category_bucket =~ /^(err|msg)-rate$/ ) && $category_bucket !~ /^empty$/; 			# don't include the empty bucket who's purpose is to normalize the buckets represented
# problem is if err-rate is 0, it is not counted, but then it is still printed.
                next if $omit_values && $category_bucket !~ /^(err-rate|msg-rate)$/;
                next if $omit_rate && $category_bucket =~ /^(err-rate|msg-rate)$/;

                if( $category_bucket =~ /-HL$/ ) {
                    $title_length = length(" $count ");
                } elsif( $category_bucket =~ /^err-rate$/ ) {
                    $title_length = length(" " . format_number( $count ) . ":");
#print "$category_bucket \"" . format_number( $count ) . "\" title length: $title_length ... ";
                } elsif( $category_bucket =~ /^msg-rate$/ ) {
                    $title_length = length( format_number( $count ) . "/m ");
#print "$category_bucket \"" . format_number( $count ) . "\" title length: $title_length ... ";
                } else {
                    $title_length = length("$category_bucket: $count ");
#print "$category_bucket \"$category_bucket: $count\" title length: $title_length ... ";
                }
                $bucket_legend_length += $title_length;
            }
            $legend_length = $bucket_legend_length if $bucket_legend_length > $legend_length;
# abc
#print "-- legend_length = $legend_length\n";

        }
#    }

    #print "Legend length: $legend_length\n";

    $durations_graph_width = $print_durations ? 59 + 3: 0;

    # Normalize counts to fit terminal width - static values based on timestamp length, some white space, maybe a vertical line spacer
    $max_graph_width = $terminal_width - $legend_length - 2 - 4 - length( $output_timestamp_format ) - $durations_graph_width;
    $max_graph_width -= 4 if $print_milliseconds;								# remove 4 characters from the X size of graph to leave room for millisecond output
    foreach my $bucket (keys %log_counts) {
        my $processed_time_buckets //= 0;
# TO DO : need to handle cases where we don't have bytes, but would have duration
        # scale the transferred bytes for printing the graph
        my $bytes = $log_stats{$bucket}{bytes};
        my $scaled_bytes = ( defined $bytes && defined $max_total_bytes && $max_total_bytes != 0 ) ? int(($bytes / $max_total_bytes) * $durations_graph_width) : 0;
        $log_stats{$bucket}{scaled_bytes} = $scaled_bytes;

        # scale the log message counts for printing the graph
        foreach my $category_bucket (keys %{$log_counts{$bucket}}) {
            my $count = $log_counts{$bucket}{$category_bucket}{count};
            my $scaled_count = $max_total_count != 0 ? int(($count / $max_total_count) * $max_graph_width) : 0;
            $log_counts{$bucket}{$category_bucket}{scaled_count} = $scaled_count;
            $category_totals{$category_bucket} += $count;							# tally the totals for each category bucket
            $total_lines_included += $count;
            $total_lines_highlighted += $count if $category_bucket =~ /-HL$/;
        }

        if( $processed_time_buckets++ % 50 == 0 ) {
            $current_memory_usage = get_memory_usage();								# track maximum memory usage
            if ($current_memory_usage > $max_memory_usage) {
                $max_memory_usage = $current_memory_usage;
            }
        }
    }

    $current_memory_usage = get_memory_usage();								# track maximum memory usage
    if ($current_memory_usage > $max_memory_usage) {
        $max_memory_usage = $current_memory_usage;
    }

    print "\r" . " " x ($terminal_width - 1) . "\r";		# clear the line of progress messages when moving on to the next file
    print "\r$colors{'bright-green'}Scaling and normalizing data completed.$colors{'NC'}";
    print " " x ( $terminal_width - length( "Scaling and normalizing data completed." ) );
    print "\n";

    return;
}

sub print_bar_graph {
    my $lines_printed = 0;
    if( $total_lines_included ) {
        print "$colors{'bright-black'}" . "─" x $terminal_width . "$colors{'NC'}\n";
        $lines_printed++;
        foreach my $bucket (sort keys %log_counts) {
            my $bucket_time_str = strftime($output_timestamp_format, gmtime($bucket));
            my $printed_chars = 0;
            $bucket_time_str .= sprintf ".%03d", ($bucket-int($bucket))*1000 if $print_milliseconds;
            print "$bucket_time_str ";
            $printed_chars += length( $bucket_time_str ) + $legend_length + 2;
            my $log_details = "";
            my $rate_metrics = "";
            my $legend_length_bucket = 0;

            foreach my $category_bucket (@log_levels) {
                if (exists $log_counts{$bucket}{$category_bucket}) {
                    my $count = $log_counts{$bucket}{$category_bucket}{count};
                    my $color = $colors{$category_bucket} // $colors{'NC'};
                    next if $omit_values && $category_bucket !~ /^(err-rate|msg-rate)$/;	# we don't want to count data that won't be printed

                    if( $category_bucket =~ /(-HL|err-rate|msg-rate)$/ ) {
                        if( $category_bucket =~ /^err-rate$/ ) {
                            $rate_metrics .= "${color}" . format_number( $count ) . "$colors{'NC'}";
                            $rate_metrics .= "$colors{'bright-black'}:$colors{'NC'}";
                            $legend_length_bucket += length( " " . format_number( $count ) . ":" );
                        } elsif( $category_bucket =~ /^msg-rate$/ ) {
                            #$rate_metrics .= "${color}$count$colors{'NC'}";
                            $rate_metrics .= "${color}" . format_number( $count ) . "$colors{'NC'}";
                            $rate_metrics .= "$colors{'bright-black'}/m$colors{'NC'} ";
                            $legend_length_bucket += length( format_number( $count ) . "/m " );
                        } else {
                            $log_details .= "${color}$count$colors{'NC'}" . " " x $category_bucket =~ /-HL$/;
                            $legend_length_bucket += length("$count ");
                        }
                    } elsif( $count < 1 ) {					 # don't include the empty bucket who's purpose is to normalize the buckets represented
                        next;
                    } else {
                        $log_details .= "$color$category_bucket: $count$colors{'NC'} ";
                        $legend_length_bucket += length("$category_bucket: $count ");
                    }
                }
            }

            print $log_details unless $omit_values;
            my $padding = $legend_length - $legend_length_bucket;

#print " legend_length: $legend_length legend_length_bucket: $legend_length_bucket padding: $padding\n";

            print " " x ($padding >= 0 ? $padding : 0);
            print " $rate_metrics" unless $omit_rate;

            print "$colors{'bright-black'}│$colors{'NC'} ";

            foreach my $category_bucket (@log_levels) {
                next unless $category_bucket !~ /^empty|err-rate|msg-rate$/; 			# don't include the empty bucket who's purpose is to normalize the buckets represented
                if (exists $log_counts{$bucket}{$category_bucket}) {
                    my $scaled_count = $log_counts{$bucket}{$category_bucket}{scaled_count};
                    my $color = $colors{$category_bucket} // $colors{'NC'};
     #               print "$color" . ('█' x $scaled_count) . "$colors{'NC'}";
                    # the following provides a mechanism for changing the look of the bars for access logs compared to other logs
                    print "$color" . ( $category_bucket =~ /^[12345]xx(-HL)?$/ ? $blocks{'I'} : $blocks{$default_chart_block} ) x $scaled_count . "$colors{'NC'}";
                    $printed_chars += $scaled_count;
                }
            }
            
            if( $print_durations ) {
                my $missing_chars =  $terminal_width - $printed_chars - $durations_graph_width - 2;		# 2 is the magic number to get 1 space after the tallest bar 
                print " " x $missing_chars;
                print " $colors{'bright-black'}│$colors{'NC'} ";
                printf( "$colors{'cyan'}%8s$colors{'NC'}  $colors{'bright-blue'}P50:%-6s$colors{'NC'} $colors{'yellow'}P90:%-6s$colors{'NC'} $colors{'red'}P95:%-6s$colors{'NC'} $colors{'white-underline'}CV:%5s$colors{'NC'} Z:%5s", defined $log_stats{$bucket}{bytes} ? format_bytes( $log_stats{$bucket}{bytes},'B' ) : "", defined $log_stats{$bucket}{p50} ? $log_stats{$bucket}{p50} : "", defined $log_stats{$bucket}{p90} ? $log_stats{$bucket}{p90} : "", defined $log_stats{$bucket}{p95} ? $log_stats{$bucket}{p95} : "", defined $log_stats{$bucket}{cv} ? $log_stats{$bucket}{cv} : "", defined $log_stats{$bucket}{z_score} ? $log_stats{$bucket}{z_score} : "" );

            }

            print "\n";
    # BUG - if using pause, the summary table won't be paused as it isn't implementing the next line
            pause_for_keypress() if( $pause_output && $lines_printed++ > 1 && $lines_printed % ( $terminal_height - 1 ) == 0 );
        }

        print "$colors{'bright-black'}" . "─" x $terminal_width . "$colors{'NC'}";
    } else {
        printf "Read $total_lines_read lines, however no lines matched any of the patterns within the timeframe.\n";
    }
    return;
}

sub access_log_stats {
	my( $bucket ) = @_;
	my( $pretty_duration, $pretty_avg_duration, $pretty_bytes );
        printf "%dms / %d s / %dMB", int( $log_analysis{$bucket}{duration} / $log_analysis{$bucket}{count} ), $log_analysis{$bucket}{duration} / 1000, int( $log_analysis{$bucket}{bytes} / 1024 / 1024 );
}


sub print_summary_table {
    my $category_column_width = 15;
    my $count_column_width = 10;
    my $table_format = "  %-${category_column_width}s %${count_column_width}d\n";

    ## START SUMMARY STATISTIC TABLE ##
    print "\n\n";
    print "  " . "─" x ( $category_column_width + $count_column_width + 1 ) . "\n";
    printf "  " . "%-${category_column_width}s %${count_column_width}s\n", "Category", "Total"; 
    print "  " . "─" x ( $category_column_width + $count_column_width + 1 ) . "\n";

    foreach my $category_bucket (@log_levels) {
        next if $category_bucket =~ /^(empty|err-rate|msg-rate)$/;
        next unless $category_totals{$category_bucket};
	
        my ( $legend_title ) =  "$category_bucket:" . " " x ( 14 - length( $category_bucket ) );
        #print "$legend_title$category_totals{$category_bucket}\n"; 
        #printf "%-${category_column_width}s %${count_column_width}d\n", $category_bucket, $category_totals{$category_bucket}; 
        printf $table_format, $category_bucket, $category_totals{$category_bucket}; 

    }
    print "  " . "─" x ( $category_column_width + $count_column_width + 1 ) . "\n";
    printf $table_format, "HIGHLIGHTED", $total_lines_highlighted if defined $highlight_regex;
    printf $table_format, "LINES INCLUDED", $total_lines_included; 
    printf $table_format, "LINES READ", $total_lines_read; 
    printf "  " . "%-${category_column_width}s %${count_column_width}s\n", "PROCESSING TIME", format_time( $elapsed, 's', 'short' );
    printf "  " . "%-${category_column_width}s %${count_column_width}s\n", "MEMORY USED", format_bytes( $max_memory_usage, 'kB' );
    print "  " . "─" x ( $category_column_width + $count_column_width + 1 ) . "\n";
    print "\n";

    ## START MESSAGE SUMMARY ##

    # Define the relative size of each column as a percentage
    my %col_relative_size;

    if( $print_durations ) {
        %col_relative_size = (
            1 => 65,
            2 => 6,
            3 => 5,
            4 => 5,
            5 => 5,
            6 => 5,
            7 => 9,
        );
    } else {
        %col_relative_size = (
            1 => 92,
            2 => 8,
        );
    }

    # Initialize the hash to store the character width of each column
    my %col_width;

    # Define the terminal width and padding values
    my $table_padding_outer = 1;  # Example outer padding
    my $table_padding_inner = 1;  # Example inner padding

    # Calculate the total table width after applying outer padding
    my $table_width = $terminal_width - (2 * $table_padding_outer);

    # Calculate the absolute width for each column based on the relative size and inner padding
    foreach my $column (keys %col_relative_size) {
        $col_width{$column} = int($table_width * $col_relative_size{$column} / 100) - (2 * $table_padding_inner);
    }

    ### DETERMINE CUT OF HIGHLIGHTED VS PLAIN MESSAGES TO PRINT ###
    # Step 1: Sort and store available messages for each category in a hash of arrays
    my %sorted_keys = (
        'highlight' => [ sort { $log_messages{'highlight'}{$b}{count} <=> $log_messages{'highlight'}{$a}{count} } keys %{$log_messages{'highlight'}} ],
        'plain' => [ sort { $log_messages{'plain'}{$b}{count} <=> $log_messages{'plain'}{$a}{count} } keys %{$log_messages{'plain'}} ],
    );

    # Initialize the hash to store top message counts
    my %top_message_count = (
        'highlight' => 0,
        'plain' => 0,
    );

    foreach my $grouping ( qw( highlight plain ) ) {
        for my $i (0 .. $#{$sorted_keys{$grouping}}) {
            last if $i >= $top_n_messages;
            $top_message_count{$grouping}++;
        }
    }

    # Step 2: Determine how many messages to print from each category
    my $half_top_n = int($top_n_messages / 2);

    # Initialize the hash to store the number of messages to print
    my %messages_to_print = (
        'highlight' => $half_top_n,
        'plain' => $half_top_n,
    );

    $messages_to_print{'highlight'}++ if $top_n_messages % 2 != 0;		# if halving doesn't equate to Top N, then add another row to highlighted messages

    # Step 3: Adjust if one category has fewer messages than needed, ensuring the total remains $top_n_messages
    if ($top_message_count{'highlight'} < $messages_to_print{'highlight'}) {
        $messages_to_print{'highlight'} = $top_message_count{'highlight'};
        $messages_to_print{'plain'} = $top_n_messages - $messages_to_print{'highlight'};
    } elsif ($top_message_count{'plain'} < $messages_to_print{'plain'}) {
        $messages_to_print{'plain'} = $top_message_count{'plain'};
        $messages_to_print{'highlight'} = $top_n_messages - $messages_to_print{'plain'};
    }

    foreach my $grouping ( qw( highlight plain ) ) {
        my $messages_printed = 0;

        # Ensure the grouping exists and is a hash reference
        if (exists $log_messages{$grouping} && ref($log_messages{$grouping}) eq 'HASH') {
            my @top_keys = (sort { $log_messages{$grouping}{$b}{count} <=> $log_messages{$grouping}{$a}{count} } keys %{$log_messages{$grouping}})[0..($top_n_messages-1)];

            next unless scalar(@top_keys) > 0;			# skip to the next category if their are no top message keys

            my $header_title = " ";

            if( $grouping eq "highlight" ) {
                $header_title = " " x $table_padding_outer . "$colors{'bright-yellow-HL'}" . " " x $table_padding_inner . sprintf( "%-$col_width{1}s", "TOP HIGHLIGHTED MESSAGES (highlighted based on RegEx pattern match)" ) . " " x $table_padding_inner;

                if( $print_durations ) {
                    $header_title .= " " x $table_padding_inner . sprintf( "%$col_width{2}s", "Count" ) . " " x $table_padding_inner; 
                    $header_title .= " " x $table_padding_inner . sprintf( "%$col_width{3}s", "P1" ) . " " x $table_padding_inner; 
                    $header_title .= " " x $table_padding_inner . sprintf( "%$col_width{4}s", "P50" ) . " " x $table_padding_inner; 
                    $header_title .= " " x $table_padding_inner . sprintf( "%$col_width{5}s", "P99" ) . " " x $table_padding_inner; 
                    $header_title .= " " x $table_padding_inner . sprintf( "%$col_width{6}s", "CV" ) . " " x $table_padding_inner; 
                    $header_title .= " " x $table_padding_inner . sprintf( "%$col_width{7}s", "Time" ) . " " x $table_padding_inner; 
                } else {
                    $header_title .= " " x $table_padding_inner . sprintf( "%$col_width{2}s", "Count" ) . " " x $table_padding_inner; 
                }

                $header_title .= "$colors{'NC'}$colors{'bright-yellow'}";
            } elsif( $grouping eq "plain" ) {
                $header_title = " " x $table_padding_outer . "$colors{'bright-cyan-HL'}" . " " x $table_padding_inner . sprintf( "%-$col_width{1}s", "TOP OVERALL MESSAGES (retained for after inclusion, exclusion, time range, and duration filters)" ) . " " x $table_padding_inner;

                if( $print_durations ) {
                    $header_title .= " " x $table_padding_inner . sprintf( "%$col_width{2}s", "Count" ) . " " x $table_padding_inner; 
                    $header_title .= " " x $table_padding_inner . sprintf( "%$col_width{3}s", "P1" ) . " " x $table_padding_inner; 
                    $header_title .= " " x $table_padding_inner . sprintf( "%$col_width{4}s", "P50" ) . " " x $table_padding_inner; 
                    $header_title .= " " x $table_padding_inner . sprintf( "%$col_width{5}s", "P99" ) . " " x $table_padding_inner; 
                    $header_title .= " " x $table_padding_inner . sprintf( "%$col_width{6}s", "CV" ) . " " x $table_padding_inner; 
                    $header_title .= " " x $table_padding_inner . sprintf( "%$col_width{7}s", "Time" ) . " " x $table_padding_inner; 
                } else {
                    $header_title .= " " x $table_padding_inner . sprintf( "%$col_width{2}s", "Count" ) . " " x $table_padding_inner; 
                }

                $header_title .= "$colors{'NC'}$colors{'bright-cyan'}";
            }

            print "$header_title\n";
            print " " x $table_padding_outer . "─" x $table_width . "$colors{'NC'}\n";

            # Print the top messages
            foreach my $key (@top_keys) {
                next if $messages_printed++ >= $messages_to_print{$grouping};
 
                my $row = " " x $table_padding_outer;

                if (defined $key && exists $log_messages{$grouping}{$key}) {
                    my $message = substr( $key, 0, $col_width{1} );
                    my $count = $log_messages{$grouping}{$key}{count};

                    if( $print_durations ) {
                        my $p1 = $log_messages{$grouping}{$key}{p1};
                        my $p50 = $log_messages{$grouping}{$key}{p50};
                        my $p99 = $log_messages{$grouping}{$key}{p99};
                        my $cv = $log_messages{$grouping}{$key}{cv};
                        my $total_duration = $log_messages{$grouping}{$key}{total_duration};

                        $row .= " " x $table_padding_inner . sprintf( "%-$col_width{1}s", $message ) . " " x $table_padding_inner; 
                        $row .= " " x $table_padding_inner . sprintf( "%$col_width{2}s", $count ) . " " x $table_padding_inner; 
                        $row .= " " x $table_padding_inner . sprintf( "%$col_width{3}s", $p1 ) . " " x $table_padding_inner; 
                        $row .= " " x $table_padding_inner . sprintf( "%$col_width{4}s", $p50 ) . " " x $table_padding_inner; 
                        $row .= " " x $table_padding_inner . sprintf( "%$col_width{5}s", $p99 ) . " " x $table_padding_inner; 
                        $row .= " " x $table_padding_inner . sprintf( "%$col_width{6}s", $cv ) . " " x $table_padding_inner; 
                        $row .= " " x $table_padding_inner . sprintf( "%$col_width{7}s", $total_duration ) . " " x $table_padding_inner; 
                    } else {
                        $row .= " " x $table_padding_inner . sprintf( "%-$col_width{1}s", $message ) . " " x $table_padding_inner; 
                        $row .= " " x $table_padding_inner . sprintf( "%$col_width{2}s", $count ) . " " x $table_padding_inner; 

                    }

                    #print "$log_messages{$grouping}{$key}{count} | $key | P1: $p1 P50: $p50 P99: $p99 CV: $cv Total: $total_duration\n";
                    print "$row\n";
                }
            }

            print "\n";

        #} else {
        #    warn "Grouping '$grouping' does not exist or is not a hash reference.\n";
        }
    }

    return;
}


## MAIN ##

print_title();
adapt_to_terminal_settings(); 
adapt_to_command_line_options();
read_and_process_logs();
initialize_empty_time_windows();
print "Calculate statistics...";
calculate_all_statistics();
normalize_data_for_output();

$end_time = [gettimeofday];
$elapsed = tv_interval($start_time, $end_time);

print "\n";
print_bar_graph();
print_summary_table() unless $omit_summary;

print "\n";
exit;
